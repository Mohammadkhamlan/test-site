export class heatmapDataAnalyzer {
    constructor() {
    }
    analyzeData(events) {
        let val = 1;
        let movementHeatMap = [];
        let clickHeatMap = [];
        events.forEach(event => {
            let pointX = 0;
            let pointY = 0;
            if (event.type != 4 && event.type != 2 && event.data.source != 0) {
                if (event.data.source == 1)
                    val = 1;
                else
                    val = 5;
                if (event.data.positions != undefined) {
                    event.data.positions.forEach(position => {
                        pointX = position.x;
                        pointY = position.y;
                        if (event.data.source == 1)
                            movementHeatMap.push({ x: pointX, y: pointY, value: val });
                        else
                            clickHeatMap.push({ x: pointX, y: pointY, value: val });
                    });
                }
                else {
                    pointX = event.data.x;
                    pointY = event.data.y;
                    if (event.data.source == 1)
                        movementHeatMap.push({ x: pointX, y: pointY, value: val });
                    else
                        clickHeatMap.push({ x: pointX, y: pointY, value: val });
                }
            }
        });
        return [clickHeatMap, movementHeatMap];
    }
    aggregationHeatMapPoints(HeatMapPoints, heatmapType) {
        let pointValue = 0;
        if (heatmapType === "movement")
            pointValue = 1;
        else
            pointValue = 5;
        HeatMapPoints.forEach((point, index) => {
            if (index != HeatMapPoints.length - 1) {
                let distanceBetweenPoints = this.calculateDistance(point, HeatMapPoints[index + 1]);
                if (distanceBetweenPoints <= 30) {
                    let newX = Math.floor((point.x + HeatMapPoints[index + 1].x) / 2);
                    let newY = Math.floor((point.y + HeatMapPoints[index + 1].y) / 2);
                    HeatMapPoints[index] = -1;
                    HeatMapPoints[index + 1] = { x: newX, y: newY, value: (point.value + pointValue) };
                }
                else {
                    HeatMapPoints[index] = { x: point.x, y: point.y, value: point.value };
                }
            }
        });
        return HeatMapPoints;
    }
    calculateDistance(point1, point2) {
        let subX = point1.x - point2.x;
        let subY = point1.y - point2.y;
        let distance = Math.sqrt(subX * subX + subY * subY);
        return distance;
    }
}
